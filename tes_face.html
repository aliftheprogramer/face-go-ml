<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Real-time Face Recognition Client</title>
    <style>
        :root {
            --bg:#1a1a1a; --fg:#f0f0f0; --panel:#2b2b2b; --border:#444; --accent:#00ff88;
        }
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; background:var(--bg); color:var(--fg); margin:0; padding:20px; display:flex; flex-direction:column; align-items:center; gap:16px; }
        h1 { margin: 0 0 8px; }
        .container { display:flex; gap:20px; width:100%; max-width:1200px; align-items:flex-start; }
        .video-container { position:relative; width:640px; height:480px; }
        video { width:640px; height:480px; border:2px solid var(--border); border-radius:8px; transform: scaleX(-1); background:#000; }
        canvas { display:none; }
        #box-overlay { position:absolute; left:0; top:0; width:640px; height:480px; pointer-events:none; }
        .bounding-box { position:absolute; border:2px solid var(--accent); background: rgba(0, 255, 136, 0.15); }
        .bounding-box-label { position:absolute; top:-20px; left:0; background:var(--accent); color:#111; padding:2px 6px; font-size:12px; border-radius:3px; }
        .panel { flex:1; display:flex; flex-direction:column; gap:14px; }
        .card { background:var(--panel); border:1px solid var(--border); border-radius:8px; padding:12px; }
        .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
        label { display:block; font-size:13px; margin-bottom:6px; opacity:0.9; }
        input { width:100%; padding:8px; background:#1e1e1e; color:var(--fg); border:1px solid var(--border); border-radius:6px; }
        button { padding:8px 12px; border:1px solid var(--border); background:#222; color:var(--fg); border-radius:6px; cursor:pointer; }
        button:hover { background:#262626; }
        pre { background:var(--panel); border:1px solid var(--border); padding:12px; border-radius:8px; white-space:pre-wrap; word-break:break-word; min-height:120px; max-height:260px; overflow:auto; }
        .ok { color: lightgreen; }
        .warn { color: orange; }
        .err { color: #ff6666; }
    </style>
</head>
<body>
    <h1>Face Recognition Client (Webcam)</h1>
    <div class="container">
        <div class="video-container">
            <video id="video" width="640" height="480" autoplay muted playsinline></video>
            <canvas id="canvas" width="640" height="480"></canvas>
            <div id="box-overlay"></div>
        </div>

        <div class="panel">
            <div class="card">
                <h2 style="margin:0 0 8px;">Config</h2>
                <div class="row">
                    <div style="flex:1; min-width:260px;">
                        <label>API Base URL</label>
                        <input id="apiBase" type="text" placeholder="http://127.0.0.1:8000" />
                    </div>
                    <div style="flex:1; min-width:260px;">
                        <label>WebSocket URL</label>
                        <input id="wsBase" type="text" placeholder="ws://127.0.0.1:8000/ws/recognitions" />
                    </div>
                </div>
                <div class="row" style="margin-top:8px;">
                    <button id="saveCfg">Save</button>
                    <button id="pingApi">Ping API</button>
                    <span id="netStatus">Status: unknown</span>
                </div>
            </div>

            <div class="card">
                <h2 style="margin:0 0 8px;">API Response</h2>
                <pre id="apiResponse">Menunggu frame...</pre>
            </div>

            <div class="card">
                <h2 style="margin:0 0 8px;">WebSocket (<span id="wsStatus">Connecting...</span>)</h2>
                <pre id="wsMessages"></pre>
            </div>
        </div>
    </div>

    <script>
        // Elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('box-overlay');
        const apiRespEl = document.getElementById('apiResponse');
        const wsMsgEl = document.getElementById('wsMessages');
        const wsStatusEl = document.getElementById('wsStatus');
        const apiBaseEl = document.getElementById('apiBase');
        const wsBaseEl = document.getElementById('wsBase');
        const saveBtn = document.getElementById('saveCfg');
        const pingBtn = document.getElementById('pingApi');
        const netStatusEl = document.getElementById('netStatus');

        // Config
        const defaults = { apiBase: 'http://127.0.0.1:8000', wsUrl: 'ws://127.0.0.1:8000/ws/recognitions' };
        function loadConfig() {
            const apiBase = localStorage.getItem('apiBase') || defaults.apiBase;
            const wsUrl = localStorage.getItem('wsUrl') || defaults.wsUrl;
            apiBaseEl.value = apiBase; wsBaseEl.value = wsUrl; return { apiBase, wsUrl };
        }
        function saveConfig() {
            localStorage.setItem('apiBase', apiBaseEl.value.trim());
            localStorage.setItem('wsUrl', wsBaseEl.value.trim());
        }
        saveBtn.onclick = () => { saveConfig(); refreshEndpoints(); setupWebSocket(true); };
        pingBtn.onclick = () => pingApi();

        let { apiBase, wsUrl } = loadConfig();
        let API_URL = `${apiBase.replace(/\/$/, '')}/recognize/realtime?min_conf=0.45`;
        let WS_URL = wsUrl;
        function refreshEndpoints() {
            ({ apiBase, wsUrl } = loadConfig());
            API_URL = `${apiBase.replace(/\/$/, '')}/recognize/realtime?min_conf=0.45`;
            WS_URL = wsUrl;
        }

        // Camera
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                await video.play();
            } catch (err) {
                console.error('Camera error:', err);
                apiRespEl.textContent = 'Error: Tidak dapat mengakses kamera. Buka lewat http(s):// (bukan file://) lalu izinkan kamera.';
            }
        }

        // Boxes (mirror overlay to match mirrored video)
        function drawBoxes(results) {
            overlay.innerHTML = '';
            const vw = video.videoWidth || 640; const vh = video.videoHeight || 480;
            overlay.style.width = vw + 'px'; overlay.style.height = vh + 'px';
            results.forEach(r => {
                const box = r.box || [0,0,0,0];
                const top = box[0]|0, right = box[1]|0, bottom = box[2]|0, left = box[3]|0;
                const el = document.createElement('div');
                el.className = 'bounding-box';
                el.style.left = Math.max(0, vw - right) + 'px';
                el.style.top = Math.max(0, top) + 'px';
                el.style.width = Math.max(0, right - left) + 'px';
                el.style.height = Math.max(0, bottom - top) + 'px';
                const label = document.createElement('div');
                label.className = 'bounding-box-label';
                const dist = (typeof r.distance === 'number') ? r.distance.toFixed(2) : 'n/a';
                label.textContent = `${r.label || 'Unknown'} (${dist})`;
                el.appendChild(label);
                overlay.appendChild(el);
            });
        }

        // Networking
        let online = false, inFlight = false, lastErr = '';
        async function sendFrame() {
            if (!online || inFlight) return; inFlight = true;
            try {
                // Draw video frame to canvas (no mirroring here)
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg'));
                const fd = new FormData(); fd.append('image', blob, 'frame.jpg');
                const controller = new AbortController(); const t = setTimeout(() => controller.abort(), 10000);
                const resp = await fetch(API_URL, { method: 'POST', body: fd, signal: controller.signal });
                clearTimeout(t);
                if (resp.ok) {
                    const data = await resp.json();
                    apiRespEl.textContent = JSON.stringify(data, null, 2);
                    const res = Array.isArray(data.results) ? data.results : (data && data.results && Array.isArray(data.results.results) ? data.results.results : []);
                    if (res && res.length) drawBoxes(res); else overlay.innerHTML = '';
                } else {
                    const txt = await resp.text();
                    apiRespEl.textContent = `Error: ${resp.status} ${resp.statusText}\n${txt}`;
                    overlay.innerHTML = '';
                }
            } catch (e) {
                lastErr = (e && e.message) ? e.message : String(e);
                apiRespEl.textContent = `Fetch error: ${lastErr}`;
                online = false; updateNetStatus();
                overlay.innerHTML = '';
            } finally {
                inFlight = false;
            }
        }

        async function pingApi() {
            refreshEndpoints();
            try {
                const controller = new AbortController(); const t = setTimeout(() => controller.abort(), 5000);
                const r = await fetch(`${apiBase.replace(/\/$/, '')}/health`, { signal: controller.signal });
                clearTimeout(t);
                online = r.ok; lastErr = r.ok ? '' : `HTTP ${r.status}`;
            } catch (e) {
                online = false; lastErr = (e && e.message) ? e.message : String(e);
            }
            updateNetStatus();
        }
        function updateNetStatus() {
            netStatusEl.textContent = online ? 'Status: online' : `Status: offline${lastErr ? ' - ' + lastErr : ''}`;
            netStatusEl.className = online ? 'ok' : 'warn';
        }

        // WebSocket with reconnect
        let ws; let wsBackoff = 1000;
        function setupWebSocket(force=false) {
            refreshEndpoints();
            if (ws && ws.readyState === WebSocket.OPEN && !force) return;
            try { if (ws) ws.close(); } catch {}
            ws = new WebSocket(WS_URL);
            ws.onopen = () => { wsStatusEl.textContent = 'Connected'; wsStatusEl.className = 'ok'; wsBackoff = 1000; };
            ws.onmessage = (evt) => {
                try {
                    const data = JSON.parse(evt.data);
                    wsMsgEl.textContent += JSON.stringify(data, null, 2) + '\n\n';
                    wsMsgEl.scrollTop = wsMsgEl.scrollHeight;
                } catch {}
            };
            ws.onerror = () => { wsStatusEl.textContent = 'Error'; wsStatusEl.className = 'err'; };
            ws.onclose = () => {
                wsStatusEl.textContent = 'Disconnected. Retrying...'; wsStatusEl.className = 'warn';
                setTimeout(() => setupWebSocket(), Math.min(wsBackoff, 10000)); wsBackoff *= 2;
            };
        }

        // Init
        async function main() {
            await setupCamera();
            await pingApi();
            setupWebSocket();
            setInterval(sendFrame, 1000);
        }
        main();
    </script>
</body>
</html>